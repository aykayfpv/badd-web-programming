"use strict";(self.webpackChunkpackages_lecture=self.webpackChunkpackages_lecture||[]).push([[2818],{2818:(e,n,t)=>{t.r(n),t.d(n,{default:()=>d});const d='// Maximale Verschachtelungstiefe finden\nconst maxDepth = maxBy(eachElementDfs(document), (item) => item.depth);\n\n// Jede Node ausgeben\nconst nodeDetails = [];\nfor (const { node, depth } of eachElementDfs(document)) {\n  // Leere Text-Nodes auslassen \n  if (node.nodeType === Node.TEXT_NODE && node.textContent.trim().length === 0) {\n    continue;\n  }\n  const indent = "  ".repeat(depth);\n  const type = findNodeTypeName(node);\n  const alignment = " ".repeat(22 + maxDepth - indent.length - type.length);\n  const details = findNodeDetails(node);\n  nodeDetails.push(\n    `${indent} - ${type}${alignment} [${node.nodeName}${details}]`,\n  );\n}\ndocument.getElementById("nodes").textContent = nodeDetails.join("\\n");\n\n// Depth-first traversal over each node\nfunction* eachElementDfs(root) {\n  const stack = [{ node: root, depth: 0 }];\n  while (stack.length > 0) {\n    const current = stack.pop();\n    yield current;\n    for (let i = current.node.childNodes.length - 1; i >= 0; i--) {\n      stack.push({\n        node: current.node.childNodes[i],\n        depth: current.depth + 1,\n      });\n    }\n    if (current.node instanceof Element) {\n      const attributes = current.node.attributes;\n      for (let i = attributes.length - 1; i >= 0; i--) {\n        stack.push({ node: attributes.item(i), depth: current.depth + 1 });\n      }\n    }\n  }\n}\n\n// Findet den Namen einer Node durch Suche in den Keys von "Node"\nfunction findNodeTypeName(node) {\n  return (\n    Object.keys(Node)\n      .filter((x) => x.endsWith("_NODE"))\n      .filter((x) => Node[x] === node.nodeType)[0] ?? "UNKNOWN"\n  );\n}\n\n// Findet zus\xe4tzliche Details f\xfcr eine Node zum Ausgeben\nfunction findNodeDetails(node) {\n  switch (node.nodeType) {\n    case Node.ATTRIBUTE_NODE:\n      return `=${node.nodeValue}`;\n    case Node.TEXT_NODE:\n      return `,${node.textContent.replace(/[\\s\\r\\n\\t]+/g, "")}`;\n    default:\n      return "";\n  }\n}\n\n// Findet das Maximum von Elementen anhand einer Funktion, die die Stelle\n// des Elements extrahiert.\nfunction maxBy(items, valueExtractor) {\n  let max = undefined;\n  for (const item of items) {\n    const value = valueExtractor(item);\n    max = max === undefined || value > max ? value : max;\n  }\n  return max;\n}'}}]);