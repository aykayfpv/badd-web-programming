"use strict";(self.webpackChunkpackages_lecture=self.webpackChunkpackages_lecture||[]).push([[2206],{16869:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>d,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"web-programming/http/http-caching","title":"Abschnitt 4 - Caching","description":"Caching zum schnelleren Laden von Webseiten","source":"@site/docs/web-programming/http/caching.mdx","sourceDirName":"web-programming/http","slug":"/http/caching","permalink":"/badd-web-programming/docs/http/caching","draft":false,"unlisted":false,"editUrl":"https://github.com/blutorange/badd-web-programming/tree/main/packages/lecture/docs/web-programming/http/caching.mdx","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"id":"http-caching","slug":"/http/caching","sidebar_position":4,"description":"Caching zum schnelleren Laden von Webseiten"},"sidebar":"tutorialSidebar","previous":{"title":"Abschnitt 3 - Session und Cookies","permalink":"/badd-web-programming/docs/http/session-cookies"},"next":{"title":"Abschnitt 5 - Web Socket","permalink":"/badd-web-programming/docs/http/web-socket"}}');var s=r(31085),t=r(71184);const d={id:"http-caching",slug:"/http/caching",sidebar_position:4,description:"Caching zum schnelleren Laden von Webseiten"},a="Abschnitt 4 - Caching",c={},o=[{value:"Cache-Control",id:"cache-control",level:2},{value:"ETag",id:"etag",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"abschnitt-4---caching",children:"Abschnitt 4 - Caching"})}),"\n",(0,s.jsx)(n.p,{children:"Bisher haben wir gesehen, wie Client und Server untereinander Nachrichten\naustauschen k\xf6nnen. Das funktioniert, jedes Request erfordert aber Zeit und\nRessourcen. Zeit, weil Daten \xfcber das Internet gesendet werden m\xfcssen \u2014\njeder m\xf6chte, dass die Webseite so schnell wie m\xf6glich l\xe4dt. Ressourcen, weil\nder Server ein Rechner ist, auf dem zum Beantworten des Requests CPU-Last\nentsteht. Gehen zu viele Anfragen auf einem Server an, kann das in einem\nZusammenbruch des Server resultieren."}),"\n",(0,s.jsx)(n.p,{children:"Daher ist es sinnvoll, Requests zu reduzieren, wenn m\xf6glich."}),"\n",(0,s.jsx)(n.p,{children:"Eine M\xf6glichkeit zur Reduzieren von Requests ist das Caching. Beim Caching\nspeichert der Browser den Inhalt der Response und verwendet diesen, statt noch\neinmal beim Server anzufragen."}),"\n",(0,s.jsx)(n.p,{children:"Sinnvoll ist das bei statischen Dateien. Wenn wir in eine Webseite ein Logo\neinbinden, ist dieser Logo bei jedem Aufruf der Webseite gleich. Es besteht\nalso keine Notwendigkeit, bei jedem Mal das Logo neu vom Server zu laden."}),"\n",(0,s.jsx)(n.p,{children:"Es kann nun aber passieren, dass wir die Webseite aktualisieren und das Logo\naustauschen. In dem Fall wollen wir, dass der Browser das Logo neu l\xe4dt.\nBei jedem Caching-Mechanismus ist es daher notwendig, eine Strategie zu haben,\nwie der Cache durchbrochen werden kann (Cache Buster)."}),"\n",(0,s.jsxs)(n.p,{children:["HTTP bietet 2 grundlegende M\xf6glichkeiten, Caching umzusetzen: ",(0,s.jsx)(n.code,{children:"Cache-Control"}),"\nund ",(0,s.jsx)(n.code,{children:"E-Tag"}),". Dies wollen wir uns in diesem Abschnitt anschauen."]}),"\n",(0,s.jsxs)(n.p,{children:["Per JavaScript ist Caching zudem noch auf eine dritte Art und Weise m\xf6glich,\nn\xe4mlich mit sogenannten ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API",children:"Service Worker"}),".\nAuf diese werden wir hier aber nicht weiter eingehen."]}),"\n",(0,s.jsx)(n.h2,{id:"cache-control",children:"Cache-Control"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Cache-Control"})," ist ein Header, den der Server in der Response setzen kann."]}),"\n",(0,s.jsx)(n.p,{children:"Mit diesem k\xf6nnen wir steuern, ob und wie lange der Browser eine Ressource cachen\ndarf."}),"\n",(0,s.jsxs)(n.p,{children:["Beispielsweise k\xf6nnte ein Server bei der Anfrage an ",(0,s.jsx)(n.code,{children:"https://example.com/logo.png"}),"\nwie folgt antworten:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"HTTP/1.1 200 OK\nContent-Type: image/png\nCache-Control: max-age=604800\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"max-age"})," gibt an, wie lange die Ressource im Cache des Browsers gehalten\nwerden darf (in Sekunden, 604800s = 1 Woche). In dem Fall stellt der Browser\nkein Request mehr an den Server und nutzt direkt die Ressource aus dem Cache."]}),"\n",(0,s.jsx)(n.p,{children:"Falls wir unter keinen Umst\xe4nden wollen, dass der Browser die Ressource cached,\nk\xf6nnen wir dies explizit anfordern mittels:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"HTTP/1.1 200 OK\nContent-Type: image/png\nCache-Control: no-store\n"})}),"\n",(0,s.jsx)(n.h2,{id:"etag",children:"ETag"}),"\n",(0,s.jsxs)(n.p,{children:["Das Problem mit ",(0,s.jsx)(n.code,{children:"max-age"})," ist, dass wir meist nicht im Voraus wissen, ob und\nwann eine Ressource aktualisiert wird. Es kann daher schwierig sein, ",(0,s.jsx)(n.code,{children:"max-age"}),"\nauf einen sinnvollen Wert zu setzen."]}),"\n",(0,s.jsxs)(n.p,{children:["Der ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/ETag",children:"ETag"}),"\n(entity tag) kann hier Abhilfe schaffen."]}),"\n",(0,s.jsx)(n.p,{children:"Die Idee dabei ist, dass jede Ressource eine Version hat. Solange die Version\ngleich ist, muss die Ressource nicht neu geladen werden. Bei der Anfrage nach\neiner Ressource liefert der Server einen ETag mit der Version zur\xfcck:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'HTTP/1.1 200 OK\nContent-Type: image/png\nETag: "bb88efe1aa703b3f70a7c92e086a5070"\n'})}),"\n",(0,s.jsx)(n.p,{children:"Der Browser speichert die Ressource zusammen mit dem ETag in seinem Cache."}),"\n",(0,s.jsx)(n.p,{children:"Ben\xf6tigt der Browser die Ressource nun erneut, etwa weil der Nutzer auf eine\nandere Unterseite navigiert, fragt der Browser beim Server erneut nach der\nRessource an. Diesmal sendet der Browser aber seinen gespeicherten ETag\nmit:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'GET https://example.com/logo.png HTTP/1.1\nIf-None-Match: "bb88efe1aa703b3f70a7c92e086a5070"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Mittels dem ",(0,s.jsx)(n.code,{children:"If-None-Match"}),"-Header bittet der Browser den Server, die Ressource\nnur zur\xfcckzuliefern, falls diese einen anderen ETag hat."]}),"\n",(0,s.jsx)(n.p,{children:"Falls die Ressource den gleichen ETag hat, teilt der Server dies nur mit und\nsendet die Ressource nicht erneut:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"HTTP/1.1 304 Not Modified\n"})}),"\n",(0,s.jsx)(n.p,{children:"\xdcber den 304-Status-Code wei\xdf der Browser nun, dass die Ressource aktuell ist\nund verwendet die Daten aus seinem Cache."}),"\n",(0,s.jsx)(n.p,{children:"Auf diese Weise kann Bandbreite gespart werden. Ung\xfcnstig ist, dass trotzdem\nein Request an den Server gestellt werden muss. Bei Verwendung von HTTP/2 bzw.\nHTTP/3 und Multiplexing kann der Overhead aber weiter reduziert werden."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["Schlie\xdflich k\xf6nne wir auch ",(0,s.jsx)(n.code,{children:"Cache-Control"})," und ",(0,s.jsx)(n.code,{children:"ETag"})," gleichzeitig verwenden.\nSo ist ein zweistufiges Vorgehen m\xf6glich. Die Idee hierbei ist,\n",(0,s.jsx)(n.code,{children:"Cache-Control"})," mit einem geringen Wert (wenige Minuten oder Stunden) zu verwenden,\num zu verhindern, dass in kurzer Zeit immer wieder neue Requests gestellt werden."]}),"\n",(0,s.jsx)(n.p,{children:"Das resultiert dann darin, dass der Browser in Intervallen von einigen Minuten oder\nStunden jeweils einmal erneut nachfragt, ob die Ressource noch aktuell ist."})]})}function l(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},71184:(e,n,r)=>{r.d(n,{R:()=>d,x:()=>a});var i=r(14041);const s={},t=i.createContext(s);function d(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);