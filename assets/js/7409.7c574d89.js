"use strict";(self.webpackChunkpackages_lecture=self.webpackChunkpackages_lecture||[]).push([[7409],{97409:(e,n,t)=>{t.r(n),t.d(n,{default:()=>r});const r='// Superklasse f\xfcr alle Formen\n// Hat einen Namen und eine Position, die ge\xe4ndert werden kann.\nclass Shape {\n  // Statischer Felder, die f\xfcr jede Instanz gleich sind\n  static #DEFAULT_NAME = "";\n\n  // Private Felder, auf die von au\xdfen nicht zugegriffen werden kann\n  // Dient dem Prinzip der Kapselung von Daten.\n  #name;\n  #x = 0;\n  #y = 0;\n\n  // Konstruktor zum Erstellen eines neuen Objekts.\n  constructor(name, width, height) {\n    // Zugriff auf statisches Feld erfolgt mittels Klassenname\n    this.#name = name ?? Shape.#DEFAULT_NAME;\n  }\n\n  // Getter f\xfcr eine Eigenschaft.\n  // Ohne Setter schreibgesch\xfctzt.\n  get name() {\n    return this.#name;\n  }\n\n  // Mit Setter ver\xe4nderbar\n  get x() {\n    return this.#x;\n  }\n\n  set x(x) {\n    this.#x = x;\n  }\n\n  get y() {\n    return this.#y;\n  }\n\n  set y(y) {\n    this.#y = y;\n  }\n\n  // Instanzmethode zum Verschieben einer Format\n  translate(dx, dy) {\n    this.#x += dx;\n    this.#y += dy;\n  }\n\n  // Ausgabe der Details der Form als String\n  toString() {\n    return `Shape[${this.#name},x=${this.#x},x=${this.#y}]`;\n  }\n}\n\n// Rechteck mit Position und Ausdehnung, sowie einem Namen.\n// Rechteck erbt von der Shape-Superklasse\n// Die Position kann ge\xe4ndert werden, H\xf6he und Breite nicht.\nclass Rectangle extends Shape {\n  // Weitere private Felder der Subklasse\n  #width = 0;\n  #height = 0;\n\n  // Konstruktor zum Erstellen eines neuen Objekts.\n  constructor(name, width, height) {\n    // Aufruf des Konstruktors der Superklasse\n    super(name);\n\n    // Belegung der Felder der Subklasse\n    this.#width = width;\n    this.#height = height;\n  }\n\n  get width() {\n    return this.#width;\n  }\n\n  get height() {\n    return this.#height;\n  }\n\n  // Checks if this rectangle intersects another rectangle\n  intersects(r2) {\n    return !(\n      this.x + this.width <= r2.x || // Komplett links von r2\n      r2.x + r2.width <= this.x || // Komplett rechts von r2\n      this.y + this.height <= r2.y || // Komplett \xfcberhalb von r2\n      r2.y + r2.height <= this.y // Komplett unterhalb von r2\n    );\n  }\n\n  // \xdcberschreiben einer Methode der Superklasse\n  toString() {\n    // Aufruf der Methode einer Superklasse\n    const superString = super.toString();\n    return `Rectangle[${superString},width=${this.#width},height=${this.#height}]`;\n  }\n\n  // Statische Factory-Methode zum Erstellen eines neuen Objekts\n  // Erstellt ein Rechteck mit H\xf6he und Breite 0\n  static minimal() {\n    return new Rectangle("minimal", 0, 0);\n  }\n}\n\n// Hitboxes f\xfcr Player und Enemy\nconst player = new Rectangle("Hakurei Reimu", 1, 1);\nconst enemy = new Rectangle("Bullet", 30, 20);\n\nconsole.log(player);\nconsole.log(enemy);\nconsole.log(`Player intersects enemy: ${player.intersects(enemy)}`);\n\n// Move player and enemy, e.g. in response to mouse movement / AI\nplayer.translate(200, 100);\nenemy.translate(150, 50);\n\n// Log player and enemy\nconsole.log(player);\nconsole.log(enemy);\nconsole.log(`Player intersects enemy: ${player.intersects(enemy)}`);\n'}}]);