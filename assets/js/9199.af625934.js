"use strict";(self.webpackChunkpackages_lecture=self.webpackChunkpackages_lecture||[]).push([[9199],{9199:(t,e,n)=>{n.r(e),n.d(e,{default:()=>o});const o='class TodoAppModel {\n  constructor() {\n    this.newTodo = ko.observable("");\n    this.todoItems = ko.observableArray();\n    this.filter = ko.observable("all");\n    this.activeCount = ko.pureComputed(\n      () => this.todoItems().filter((x) => !x.completed()).length,\n    );\n    this.filteredTodoItems = ko.pureComputed(() =>\n      this._computeFilteredTodoItems(),\n    );\n\n    // Store in localStorage whenever persistent state changes\n    ko.pureComputed(() => this.toJS()).subscribe((data) => storeTodoItems(data));\n\n    bindMethods(this);\n  }\n\n  addTodo(_, event) {\n    if (event.key === "Enter") {\n      const newContent = this.newTodo().trim();\n      if (newContent) {\n        const newItem = new TodoItem(this.newTodo());\n        this.todoItems.push(newItem);\n        this.newTodo("");\n      }\n    }\n    return true;\n  }\n\n  editTodo(itemToEdit) {\n    for (const item of this.todoItems()) {\n      item.stopEdit(false);\n    }\n    itemToEdit.startEdit();\n  }\n\n  removeTodo(itemToRemove) {\n    this.todoItems.remove(itemToRemove);\n  }\n\n  removeCompletedTodos() {\n    this.todoItems.remove((item) => item.completed());\n  }\n\n  toggleAll() {\n    const allCompleted = this.todoItems().every((x) => x.completed());\n    for (const item of this.todoItems()) {\n      item.completed(!allCompleted);\n    }\n  }\n\n  filterAll() {\n    this.filter("all");\n  }\n\n  filterActive() {\n    this.filter("active");\n  }\n\n  filterCompleted() {\n    this.filter("completed");\n  }\n\n  toJS() {\n    return {\n      items: this.todoItems().map((item) => item.toJS()),\n    };\n  }\n\n  _computeFilteredTodoItems() {\n    switch (this.filter()) {\n      case "all":\n        return [...this.todoItems()];\n      case "active":\n        return this.todoItems().filter((x) => !x.completed());\n      case "completed":\n        return this.todoItems().filter((x) => x.completed());\n    }\n  }\n\n  static fromJS(data) {\n    const model = new TodoAppModel();\n    if (data && typeof data === "object") {\n      for (const item of data.items) {\n        const todoItem = TodoItem.fromJS(item);\n        model.todoItems.push(todoItem);\n      }\n    }\n    return model;\n  }\n}\n\nclass TodoItem {\n  constructor(text) {\n    this.completed = ko.observable(false);\n    this.content = ko.observable(text);\n    this.newContent = ko.observable("");\n    this.editing = ko.observable(false);\n    this.classNames = ko.pureComputed(() => this._computeClassNames());\n    bindMethods(this);\n  }\n\n  startEdit() {\n    this.editing(true);\n    this.newContent(this.content());\n  }\n\n  stopEdit() {\n    this.editing(false);\n  }\n\n  onKeyDown(_, event) {\n    if (event.key === "Enter") {\n      const newContent = this.newContent().trim();\n      this.editing(false);\n      this.content(newContent || this.content());\n    }\n    if (event.key === "Escape") {\n      this.editing(false);\n    }\n    return true;\n  }\n\n  toJS() {\n    return { completed: this.completed(), content: this.content() };\n  }\n\n  _computeClassNames() {\n    const classes = [];\n    this.completed() && classes.push("completed");\n    this.editing() && classes.push("editing");\n    return classes.join(" ");\n  }\n\n  static fromJS(data) {\n    const todoItem = new TodoItem();\n    todoItem.completed(data.completed);\n    todoItem.content(data.content);\n    return todoItem;\n  }\n}\n\nko.applyBindings(TodoAppModel.fromJS(loadTodoItems()));\n\n// Speichern und Laden im localStorage\nfunction storeTodoItems(todoData) {\n  localStorage.setItem("todo-app-items-knockout", JSON.stringify(todoData));\n}\n\nfunction loadTodoItems() {\n  try {\n    const itemDataString = localStorage.getItem("todo-app-items-knockout");\n    return itemDataString ? JSON.parse(itemDataString) : undefined;\n  } catch (e) {\n    console.error(\n      "Could not load items from local storage -- corrupted data?",\n      e,\n    );\n    return undefined;\n  }\n}\n\n// Helper that binds all class methods of an instance to the instance, so that\n// this always refers to the instance.\nfunction bindMethods(instance) {\n  const proto = Object.getPrototypeOf(instance);\n  for (const key of Object.getOwnPropertyNames(proto)) {\n    if (typeof proto[key] === "function" && key !== "constructor") {\n      instance[key] = instance[key].bind(instance);\n    }\n  }\n}\n'}}]);